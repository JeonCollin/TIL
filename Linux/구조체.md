# 구조체 선언
```c
Struct _Student
{
  int iGrade;
  int iNumber;
  char Name[10];
  double dHeight;
  double dWeight;
}; // 세미콜론 필수: 없으면 함수로 인식할 수도 있음

sturct _Student Student; // C에서의 정의
_Student Student; // C++에서의 정의
```

## (참고) 구조체 변수 만들기
```c
Struct _Student
{
  int iGrade;
  int iNumber;
  char Name[10];
  double dHeight;
  double dWeight;
}Student1, Student2;
```

## 구조체 변수 초기화
```c
// 1. 구조체에 선언된 변수 순서대로 입력
struct _Student Student1 = {1, 104, "전콜린", 179.53, 72.65};

// 2. 멤버 이용
struct _Student Student1;
Student1.iGrade = 1;
Student1.iNumber = 104;
Student1.Name[0] = 0xBC // 전
Student1.Name[1] = 0xAD;
Student1.Name[2] = 0xB3 // 콜
Student1.Name[3] = 0xAA;
Student1.Name[4] = 0xBF // 린
Student1.Name[5] = 0xAC;
// 한글은 2 Byte라서 저렇게 해야한다는데 모르겠다
Student1.dHeight = 179.53;
Student1.dWeight = 72.65;
```

## 구조체의 크기
```c
// 구조체 자체의 크기
sizeof(struct _Student);

// 구조체 변수(인스턴스)의 크기
sizeof Student1;
```

## 구조체 중첩하기
```c
struct _Score
{
  int iKorean;
  int iEnglish;
  int iMath;
};

struct _Stuent
{
  int iGrade;
  int iNumber;
  char Name[10];
  double dHeight;
  double dWeight;
  // 이전의 구조체 활용
  struct _Score Score;
};

int main()
{
  // 구조체 선언1: 구조체 내부에 또 구조체를 선언하면 된다
  struct _Student Student1 = {1, 104, "전콜린", 179.53, 72.53, {80, 100, 95}};

  // 구조체 선언2: nest된 멤버
  Student1.iGrede = 1;
  Student1.iNumber = 104;
  Student1.Name = "전콜린" // 실제 문자열 선언은 이것과 다름
  Student1.dHeight = 179.53;
  Student1.dWeight = 72.53;
  Student1.Score.iKorean = 80;
  Student1.Score.iEnglish = 100;
  Student1.Score.iMath = 95;
}
```

# Typedef
- 정의된 이름을 간단하게 다시 만들 때 사용
- 형식: `typedef [재정의할 자료형] [재정의된 이름]`
- ex: `typedef unsigned int Myuint`
- `unsigned int num` == `Myuint num`: 치환해서 사용 가능

## 구조체에서 typedef
- OOP같이 클래스 이름만 사용해서 정의 가능
```c
struct _Food
{
  char Name[10];
  int iprice;
  int iCookTime;
};

typedef struct _Food
{
  char Name[10];
  int iprice;
  int iCookTime;
}FOOD;

// 사용할 때
int main()
{
  // 기존 구조체
  struct _Food food1 = {"빵", 1000, 30};
  // typedef를 활용한 구조체
  FOOD food2 = {"밥", 1000, 20};
}
```

# 구조체의 배열
- 클래스로 치면, 인스턴스들을 같은 배열에 묶어서 저장 가능
```
typdef struct _Personal
{
  char Name[10];
  int age;
}PERSONAL;

typedef struct _Grade
{
  int iKorean;
  int iMatch;
  int iEnglish;
}GRADE;

typedef struct _StudentInfo
{
  PERSONAL Personal;
  GRADE Grade;
} StudentInfo;

int main()
{
  // 1. 그냥 생성: 학생들의 정보가 담긴 리스트 생성 (철수, 영희 두 명)
  StudentInfo StudentList[10] =
  {
    {{"철수", 20}, {90, 95, 100}},
    {{"영희", 21}, {95, 95, 95}}
  };
}
```

## 구조체 배열의 포인터
- 배열의 주소로 변수를 설정할 수 있듯이, 포인터로도 변경할 수 있다
```
typdef struct _Personal
{
  char Name[10];
  int age;
}PERSONAL, *PPERSONAL; //*을 붙였으니 포인터 변수

typedef struct _Grade
{
  int iKorean;
  int iMath;
  int iEnglish;
}GRADE, *PGRADE;

typedef struct _StudentInfo
{
  PERSONAL Personal;
  GRADE Grade;

  // 학생들의 정보가 담긴 리스트의 이전/다음 배열 주소
  struct _StudentInfo *pNext;
  struct _StudentInfo *pRear;
} StudentInfo, *PSTUDENTINFO;

int main()
{
  // 1. 그냥 생성: 학생들의 정보가 담긴 리스트 생성 (철수, 영희 두 명)
  StudentInfo StudentList[10] =
  {
    {{"철수", 20}, {90, 95, 100}},
    {{"영희", 21}, {95, 95, 95}},
    &StudentList[1], // *pNext
    &StudentList[0] // *pRear
  };

  // 2. 구조체의 포인턴 변수 선언
  PSTUDENTINFO pStudentList = studentList;

  // 2-1. 활용: 포인터로 접근했으면 .대신 ->사용
  printf(pStudentList[1].pRear->Persoanl.Name); // 두 번째 학생의 이전 == 철수
  printf(pStudentList[0].pNext->Grade.iKorean); // 첫 번째 학생의 이후 == 영희
}

// 3. 함수에서 구조체 활용
void Using_Pstructure(PSTUDENTINFO pStudentInfo)
{
  printf(pStudentInfo->Personal.Name); // 이름 출력
  printf(pStudentInfo->Grade.iMath); // 수학성적 출력
}
```

# 참고: enum
- 상수형을 정의하는 구조체
```c
typedef enum _Location
{
  CITY,
  SCHOOL,
  HOSPITAL
}LOCATION;

// 열거형 변수 선언
enum _Location Location1;
LOCATION Location2;

// 열거형 변수 활용
int main()
{
  LOCATION Location;
  Location = 0; // 실제로 정수형은 아님, (Location == CITY)
  Location = 1; // 실제로 정수형은 아님, (Location == SCHOOL)
  Location = 2; // 실제로 정수형은 아님, (Location == HOSPITAL)
}
```
