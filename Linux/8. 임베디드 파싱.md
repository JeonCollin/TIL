# 임베디드 파싱
- string.h 사용

# 문자열 생성
1. `const char *v = "abcd"`: 읽기전용
2. `char v[10] = "abcd"`: 배열을 이용한 선언 >> 수정 가능

# 문자열 함수
- `size strlen()`: null 전까지 문자열 길이 반환
- `char* strcpy(a, b)`: a에 b를 복사
- `char* strncpy(a, b, n)`: a에 b를 n번 인덱스부터 복사
- `char* strcat(a, b)`: a에 b를 이어붙임
- `char* strncat(a, b, 2)`: a에 b를 n개 이어붙임
- `int strcmp(a, b)`: a기준 b 비교 >> 아스키코드 기준으로 같으면 0, 앞서면 -1, 뒤면 1

- `int atoi(string)`:문자열을 정수로
- `char* strtok(주소, 찾을 토큰)`: 문자열을 지정된 구분자로 토큰으로 분리(split)
  - 찾은 토큰을 가리키는 포인터를 반환한다, 없으면 null
  - 구분자를 찾으면 null로 변환
  - 이어서 찾을 때는 포인터가 반환되어서 이어서 추적
```c
char temp[30] = "AA#BB#CC";

// 포인터 p에  최초의 #포인터가 저장됨
char* p = strtok(temp, "#"); // temp = "AA()BB#CC"

// Null주소부터 시작
p = strtok(NULL, "#"); // temp = "AA()BB()CC"
p = strtok(NULL, "#");
```

- `char* strchr()`: 문자열에서 문자 찾기
  - 그 위치의 포인터 return, 없으면 null
- `char* strstr()`: 문자열에서 문자열 찾기
  - 대소문자 구분함, 그 위치의 포인터 return, 없으면 null

## 제일 중요
- `int sscanf(vect, "[%f]%s%d", &time, msg, &num)`: 문자열에서 형식화된 데이터를 읽어온다
- `int sprintf()`
```c
char vect[30] = "[30.2123] message 24"
float time;
char msg[30];
int num;

sscanf(vect, "[%f]%s%d", &time, msg, &num);
// vect 문자열에서 ([실수] 문자 정수) 형식으로 값을 뽑아낸다
printf("%f %s %d\n", time, msg, num);

char temp[30];
sprintf(temp, "[%.6f] %s %d", time, msg, num);
// temp에 ([6자리 실수] 문자 정수) 형식으로 저장
printf("%s\n", temp);
```
